def import -params 1 %{
    try %{
        source %sh{echo $XDG_CONFIG_HOME/kak/$1.kak}
    }
}

def plug -params 1 %{
    %sh{
        if [[ ! -d $HOME/build/$1 ]]; then
            (cd $HOME/build; git clone https://github.com/$1)
        fi
        for file in $(echo $HOME/build/$(basename $1)/*.kak); do
            echo source "$file"
        done
    }
}

#plug Delapouite/kakoune-expand-region

hook global BufCreate .*[.](ts) %{
    set buffer filetype typescript
}

import autowrap
import backspace
import hl-curword
import marks-submap
import one-char-replace
import reload-kakrc
import same-point-insert
import selections
import z-submap

# Dvorak movement, dodging empty lines
import nonempty-lines
map global normal t 'j:while-empty j<ret>'
map global normal n 'k:while-empty k<ret>'
map global normal T 'J:while-empty J<ret>'
map global normal N 'K:while-empty K<ret>'
map global normal s l
map global normal S L

# Remove empty lines above and under
map global normal x ':remove-adjacent-empty-line j<ret>'
map global normal X ':remove-adjacent-empty-line k<ret>'
map global normal <a-x> ':remove-all-adjacent-empty-lines<ret>'

# Make new selections above and under, left and right, and at words
def newsel -params 1 %{
    eval -with-maps -save-regs i %{
        exec \"iZ
        exec %arg{1}
        exec \"i<a-z>
    }
    print-selection-info
}
map global normal <c-t>       C
map global normal <c-n>       <a-C>
map global normal <backspace> ':newsel h<ret>'
map global normal <c-s>       ':newsel l<ret>'
map global normal <c-w>       ':newsel <lt>a-w<gt> <ret>'
map global normal <c-e>       ':newsel <lt>a-e<gt> <ret>'
map global normal <c-b>       ':newsel <lt>a-b<gt> <ret>'
map global normal <a-m>       ':newsel m\;<ret>'
                 # <c-m> is <ret>

# Select paragraphs (Use <a-i>p and repeat with full-line-ifte?)
map global normal <a-t> ]p
map global normal <a-T> }p
map global normal <a-n> [p
map global normal <a-N> {p

# Extend selections left and right
map global normal <A-s>   <A-l>
map global normal <A-S>   <A-L>
map global normal <A-h>   \;Gi
map global normal <A-H>   Gi
#map global normal <A-a>   <A-h>
#map global normal <A-A>   <A-H>

# Outer object <a-[oO]>
map global normal <a-o> <a-a>
map global normal <a-O> <a-A>


# g: next/prev match
map global normal g     n978vh
map global normal G     N978vh
map global normal <a-g> <a-n>978vh
map global normal <a-G> <a-N>978vh

# Marks submap
map global normal j :marks<ret>

# J a'la vim
def J %{exec -itersel -no-hooks <A-J><a-m>c<space><esc><space>vm }
map global normal J :J<ret>
map -docstring join global user   j <A-J>

# Overwrite a'la vim R
import overwrite
map global normal R :overwrite<ret>

# t on k
map global normal k     t
map global normal K     T
map global normal <a-k> <a-t>
map global normal <a-K> <a-T>

# Split and select
map global normal -- - s
map global normal L S
map global normal l <A-s>

#map global user   a :echo'@'<ret>
#:select-all-focus-closest<ret>
map global normal @ :select-all-focus-closest<ret>
map global normal _ ':exec s<ret><ret>'

#map -docstring %{select all} global user   a :select-all-focus-closest<ret>

# Keep selections
map -docstring %{keep} global user k <a-k>
map -docstring %{keep not} global user K <a-K>

# Line selection commands on v as in vim's visual mode
import line-selection
map global normal v     :line-select<ret>
map global normal V     X
map global normal <A-v> <A-x>
map global normal <A-V> <A-X>
map global normal <c-v> :line-new-cursor<ret>

# Prompt on ;
map global normal \; :

# Macros
map global normal <esc> '<esc>:noh<ret>'

# ret...
map -docstring <ret> global user <ret> <ret>

# Nav
map global normal <space> '<space>:pagewise j<ret>'
map global normal <ret>   '<space>:pagewise k<ret>'

decl int viewport_y
decl int viewport_h
def viewport_update %{
    eval -save-regs ct %{
        eval -draft -no-hooks %{
            reg c %val{cursor_line}
            exec gt
            reg t %val{cursor_line}
        }
        set window viewport_y %sh{ echo $(($kak_reg_c - $kak_reg_t)) }
    }
}

def pagewise -params 1 %{
    viewport_update
    exec %val{window_height} %arg{1} vt %opt{viewport_y} vk
}

def viewport_preserve -params 1 %{
    viewport_update
    exec %arg{1} vt %opt{viewport_y} vk
}

map global normal <c-g> ':viewport_preserve n<ret>'

# Selection fiddling
map global normal : \;
map global normal * lbhe*
map -docstring * global user   8 *
map global normal D ":echo '<a-2>'<ret>"
map global normal <a-2> \%

map global normal = <space>

def selinfo %{
    info '
<a-;>  swap direction
<a-:>  face forward
jo     one selection (space)
:      reduce selection to cursor (;)
    '
}

hook -group kakrc global NormalKey '^(<a-[:;]>|<space>|;)$' selinfo

# Rotate selections on "
map global normal '"' '<a-">'

# Register
map -docstring register global user "'" '"'

# Paste and replace
map global normal <a-r> R

# Xclipboard
map -docstring 'xser paste'    global user p %{<a-!>xsel<ret>}
map -docstring 'xsel Paste'    global user P %{!xsel<ret>}
map -docstring 'xsel replace'  global user R %{:reg w "%sh{xsel}"<ret>"wR}
map -docstring 'xcopy bufname' global user y %{:xcopy %val{bufname}<ret>}
map -docstring 'xcopy buffile' global user Y %{:xcopy %val{buffile}<ret>}

def xcopy -params 0..1 %{%sh{
  if [ -z "$1" ]; then
    val="$kak_reg_dquote"
  else
    val=$1
  fi
  echo -n "$val" | xsel --input --primary
  echo -n "$val" | xsel --input --clipboard
  l=$(echo -n "$val" | wc -l)
  val=${val//\\/\\}
  val=${val//./\\.}
  if [[ $l -eq 0 ]]; then
    echo echo "copied %.$val."
  elif [[ $l -eq 1 ]]; then
    echo echo "copied 1 line"
  else
    echo echo "copied $l lines"
  fi
}}

# Sync %reg{"} with X clipboard, idea from alexherbo2
hook global -group kakrc NormalKey y %{xcopy}

# Execute current selection(s)
map -docstring eval global user x %{:eval -itersel %val{selection}<ret>}

# Write and close buffer
map -docstring write  global user w :w<ret>
map -docstring bufdel global user d %{ :delete-buffer<ret>:exec ga<ret> }

# Comment line
map global normal '#' :comment-line<ret>

# Buffers
map global normal <a-,> :bp<ret>:bufinfo<ret>
map global normal <a-.> :bn<ret>:bufinfo<ret>
map global normal <a--> ga:bufinfo<ret>
map global normal <a-d> :db<ret>:bufinfo<ret>
map global normal <a-q> :db!<ret>:bufinfo<ret>

def bufinfo %{
    %sh{
        echo -n info -- %^
        (while read -d : buf; do
            if [[ "$buf" == "$kak_bufname" ]]; then
                echo "> $buf <"
            else
                echo "  $buf  "
            fi
        done) <<< "$kak_buflist"
        echo ^
    }
}

# fzf
import fzf
map -docstring "bufzf"      global user b ":bufzf<ret>"
map -docstring "fzf-file"   global user f ":fzf-file<ret>"
map -docstring "fzf-file ~" global user F ":fzf-file ~<ret>"
map -docstring "fzf-cd"     global user c ":fzf-cd<ret>"
map -docstring "fzf-cd ~"   global user C ":fzf-cd ~<ret>"
map -docstring "fzf-git"    global user g ":fzf-git<ret>"

map global normal <a-c> ':fzf-cd<ret>'

# Format using fmt
map -docstring format global user q '|fmt -w 80<ret>:echo -color green [sel] | fmt -w 80<ret>'

# Object map
# Some upper-case variants:
map global object P p
map global object I i

#

# Aliases
alias global colo colorscheme
alias global wqa  write-all-quit
alias global bd   delete-buffer
alias global bd!  delete-buffer!
alias global rg   grep
def setf -params 1 %{set buffer filetype %arg{1}}
def auinfo %{set -add window autoinfo normal}
def gitcd  %{cd %sh{cd $(dirname $kak_buffile); git rev-parse --show-toplevel}}
def filecd %{cd %sh{echo $(dirname $kak_buffile)}}

map -docstring pwd global user ` %{:echo %val{client_env_PWD}<ret>}

# Auto-mkdir when saving buffer to file, from alexherbo2
hook global -group kakrc BufWritePre .* %{ nop %sh{
  dir=$(dirname $kak_buffile)
  [ -d $dir ] || mkdir --parents $dir
}}

# Remove trailing whitespaces before saving
hook global -group trim_whitespace_pre_buf_write BufWritePre .* %{
  try %{ exec -no-hooks -draft '%s\h+$<ret>d' }
}
hook global -group expandtabs_pre_buf_write BufWritePre .* %{
  try %{ exec -no-hooks -draft '%@' }
}

hook global BufSetOption filetype=makefile %{
  set buffer disabled_hooks expandtabs.*
  addhl show_whitespaces -lf ' ' -spc ' '
}

# Options
set global ui_options ncurses_assistant=none
set global tabstop 4
set global idle_timeout 50
set global scrolloff 1,0

# Insert mode
map global insert <c-s> <c-o>    ; # silent: stop completion
map global insert <c-c> <c-x>    ; # complete here
map global insert <c-k> <c-v>    ; # raw insert, use vim binding
map global insert <c-y> '<c-r>"' ; # paste from normal yank register, readline key
map global insert <c-h> <a-\;>   ; # execute one normal kak command

# Jedi
map -docstring goto      global user . ':jedi goto<ret>'
map -docstring docstring global user h ':jedi docstring<ret>'
map -docstring usages    global user u ':jedi usages<ret>'

# Reload .Xresources upon saving it
rmhooks global reload_xres
hook -group reload_xres global BufWritePost .*Xresources %{
  nop %sh{ xrdb -merge ~/.Xresources }
  echo xrdb -merge %val{bufname}
}

# Window setup
def my-window-setup %{
    try %{ addhl show_matching }
    face CurWord default+b
    try %{ addhl dynregex '%opt{curword}' 0:CurWord }

    hook global -group kakrc WinResize .* %{
        echo "%val{window_height}:%val{window_width}"
    }

    rmhl red80
    addhl group red80
    addhl -group red80 regex ^[^\n]{80}([^\n]) 1:default,rgb:ffcccc

    # set window completers filename
    map window insert <tab> '<a-;>:contextual-tab<ret>'
}

map global insert <a-w> <c-x><c-w>
map global insert <a-c> '<a-;>:eval -draft %(exec b; lsp_complete)<ret>'
map global insert <a-h> '<a-;>:lsp_signature_help<ret>'


def contextual-tab -docstring "To be bound in insert mode" %{
    try %{
        # Complete if current char is whitespace, and previous is not
        exec -draft '<esc><space>;<a-k>\s<ret>h<a-k>\S<ret>'
        eval -draft %(exec b; lsp_complete)
        #exec <c-x><c-w>
    } catch %{
        # Otherwise just insert a tab
        exec <tab>
    }
}

# auto indent
hook -group copyindent global InsertChar \n %{ exec -draft -itersel K<a-&> }

# Auto expand tabs into spaces
hook -group expandtabs global InsertChar \t %{ exec -draft -itersel x@ }

set global grepcmd 'rg -n'

hook global -group kakrc WinCreate .* my-window-setup

hook global -group kakrc BufCreate .*(bashrc|xinitrc).* %{
    set buffer filetype sh
}

hook global -group kakrc BufCreate .*(Makefile).* %{
    set buffer filetype makefile
}

decl str lsp_servers %{
    python:pyls
    typescript:node /home/dan/build/javascript-typescript-langserver/lib/language-server-stdio.js
    javascript:node /home/dan/build/javascript-typescript-langserver/lib/language-server-stdio.js
    go:/home/dan/go/bin/go-langserver
}
decl str lsp_python_disabled_diagnostics '^E501'

#hook global InsertChar [.] %{try lsp_complete}
hook global InsertChar [,] %{try lsp_signature_help}

map global -docstring 'lsp goto'  user . ':lsp_goto_definition<ret>'
map global -docstring 'lsp refs'  user u ':lsp_references<ret>'
map global -docstring 'hover docs'   user h ':lsp_hover docsclient<ret>'
map global -docstring 'hover cursor' user H ':lsp_hover cursor<ret>'
map global -docstring 'hover info'   user i ':lsp_hover info<ret>'

# should be grep-next in grep buffer
map global -docstring 'lsp next' user t ':lsp_diagnostics_jump next cursor<ret>'
map global -docstring 'lsp prev' user n ':lsp_diagnostics_jump prev cursor<ret>'
map global -docstring diagnostics user e ':lsp_diagnostics cursor<ret>'

#set-option global completers filename:word=buffer:option=lsp_completions
hook global WinCreate .* %{
    try %{
        add-highlighter flag_lines default lsp_flags
    }
}

hook global -group kakrc BufCreate .*kak.* "set -add buffer completion_extra_word_char -"

hook global -group kakrc InsertCompletionShow .* %{
    map window insert <tab> <c-n>
    map window insert <backtab> <c-p>
}
hook global -group kakrc InsertCompletionHide .* %{
    map window insert <tab>     '<a-;>:contextual-tab<ret>'
    map global insert <backtab> '<a-;>:backspace<ret>'
}

hook global -group kakrc BufOpenFifo '\*grep\*' %{ map -docstring grep-next global user n ':grep-next<ret>' }

hook global -group kakrc WinSetOption filetype=(c|cpp) %{
    clang-enable-autocomplete
    clang-enable-diagnostics
    alias window lint clang-parse
    alias window lint-next clang-diagnostics-next
    %sh{
        if [ $PWD = "/home/dan/code/kakoune/src" ]; then
           echo "set buffer clang_options '-std=c++14 -DKAK_DEBUG'"
           # -include-pch precomp-header.h.gch -DKAK_DEBUG'"
        fi
    }
    #ycmd-enable-autocomplete
}

hook global -group kakrc WinSetOption filetype=sh %{
    set buffer lintcmd 'shellcheck -fgcc -eSC2006'
    lint-enable
}

hook global BufSetOption filetype=pug %{
  set buffer tabstop 2
  set buffer disabled_hooks (pug-hooks|pug-indent)
}

hook global -group kakrc WinSetOption filetype=python %{
    set buffer lintcmd 'flake8 --filename=*'
    #lint-enable
}

def ide %{
    rename-client main
    new rename-client docs
    new rename-client tools
    set global docsclient docs
    set global toolsclient tools
    set global jumpclient main
}

colorscheme solarized

# by lenormf, see https://github.com/mawww/kakoune/issues/1192
decl -hidden range-faces show_matching_range

hook global -group kakrc InsertChar .+ %{ eval -draft %{
    set buffer show_matching_range ""

    try %{
        exec <esc>\;hm<a-k>..<ret>\;
        set buffer show_matching_range "%val{timestamp}:%val{selection_desc}|MatchingChar"
    }
} }

hook global -group kakrc InsertEnd .* %{
    set buffer show_matching_range ""
}

hook global -group kakrc WinCreate .* %{

    addhl ranges show_matching_range
}

# make import and plug look like keywords :)
try %{
    add-highlighter -group /kakrc/code regex \b(import|plug)\b 0:keyword
}

map -docstring '/(?i)'     global user '/'     /(?i)
map -docstring '<a-/>(?i)' global user '<a-/>' <a-/>(?i)
map -docstring '?(?i)'     global user '?'     ?(?i)
map -docstring '<a-?>(?i)' global user '<a-?>' <a-?>(?i)

map global normal <a-8> ':buffer *debug*<ret>'
map global normal <a-3> ':edit ~/.kakrc<ret>'

set global modelinefmt %{
{{mode_info}}{{context_info}} |
%val{cursor_line}:%val{cursor_char_column} |
%val{bufname} |
%sh{[[ $kak_client != unnamed* ]] && echo "$kak_client | "}%val{session}}
set global modelinefmt %{
{{mode_info}}{{context_info}} |
%val{cursor_line}:%val{cursor_char_column} |
%val{bufname} |
%val{client} |
%val{session}}
