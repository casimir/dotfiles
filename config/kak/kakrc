# Dvorak movement, dodging empty lines
map global normal t 'j:while-empty j<ret>'
map global normal n 'k:while-empty k<ret>'
map global normal T 'J:while-empty J<ret>'
map global normal N 'K:while-empty K<ret>'
map global normal s l
map global normal S L

# Make new selections above and under, left and right
map global normal <c-t> C
map global normal <c-n> <a-C>
map global normal <backspace> '"iZh"i<a-z>'
map global normal <c-s> '"iZl"i<a-z>'

# Select paragraphs (Use <a-i>p and repeat with full-line-ifte?)
map global normal <a-t> ]p
map global normal <a-T> }p
map global normal <a-n> [p
map global normal <a-N> {p

# Extend selections left and right
map global normal <A-s>   <A-l>
map global normal <A-S>   <A-L>
map global normal <A-h>   gi
map global normal <A-H>   Gi
map global normal <A-a>   <A-h>
map global normal <A-A>   <A-H>

# Outer object <a-[oO]>
map global normal <a-o> <a-a>
map global normal <a-O> <a-A>

# Remove empty lines above and under
map global normal x ':remove-adjacent-empty-line<ret>'
map global normal X ':remove-all-adjacent-empty-lines<ret>'

# Delete current line(s)
map global normal D     <a-x>dgi

# g/f: next/prev match
map global normal g n
map global normal G N:print-selection-info<ret>
map global normal f <A-n>
map global normal F <A-N>:print-selection-info<ret>

# marks submap
map global normal j :marks<ret>

# J a'la vim
map global normal J     <A-J>
map global user   j     <A-j>

# Overwrite a'la vim R
map global normal R :overwrite<ret>

# F/T on Q/K, also swap alt/shift
map global normal k     t
map global normal K     <a-t>
map global normal <a-k> T
map global normal <a-K> <a-T>
map global normal q     f
map global normal Q     <a-f>
map global normal <a-q> F
map global normal <a-Q> <a-F>

# Split and select
map global user '/' s
map global user s S
map global user a :select-all-focus-closest<ret>
map global normal l <A-s>

# Keep selections
map global user k <a-k>
map global user K ':echo zk<ret>'

# Macros
def -docstring Q rec  'exec Q'
def -docstring q play 'exec q'

# Line selection commands on v as in vim's visual mode
map global normal v     :line-select<ret>
map global normal V     X
map global normal <A-v> <A-x>
map global normal <A-V> <A-X>
map global normal <c-v> :line-new-cursor<ret>

# Pretend ; is :
map global normal \; :

# Selection fiddling
map global normal <space> <space>
map global normal <esc>   '\;:noh<ret>'
map global normal :       '<A-;>'
map global normal * lbhe*
map global user   8 *

# Rotate selections on ' and "
map global normal "'" "':print-selection-info<ret>"
map global normal '"' "<A-'>:print-selection-info<ret>"

# Register
map global normal -- - '"'

# Paste and replace
map global normal <a-r> R

# Xclipboard
map global user p %{<a-!>xsel<ret>:echo -color Information %{pasted from X clipboard}<ret>}
map global user P %{!xsel<ret>:echo -color Information %{pasted from X clipboard}<ret>}
map global user R %{:reg w "%sh{xsel}"<ret>"wR:echo -color Information %{replaced from X clipboard }<ret>}

# Sync %reg{"} with X clipboard, from alexherbo2
hook global -group kakrc NormalKey y %{ nop %sh{
  printf %s "$kak_reg_dquote" | xsel --input --clipboard
  printf %s "$kak_reg_dquote" | xsel --input --primary
}}

# Execute current selection(s)
map global user x %{:eval -itersel %val{selection}<ret>}

# Write and close buffer
map global user w :w<ret>
map global user d %{ :delete-buffer<ret>:exec ga<ret> }

# Comment line
map global normal '#' :comment-line<ret>

# fzf
map global user b ":bufzf<ret>"
map global user f "<esc>:fzf-file<ret>"
map global user F "<esc>:fzf-file ~<ret>"
map global user c "<esc>:fzf-cd<ret>"
map global user C "<esc>:fzf-cd ~<ret>"
map global user g "<esc>:fzf-git<ret>"

# Format using fmt
map global user q '|fmt -w 80<ret>:echo -color green [sel] | fmt -w 80<ret>'

# Object map
# Some upper-case variants:
map global object P p
map global object I i

# Aliases
alias global colo colorscheme
alias global wqa  write-all-quit
alias global bd   delete-buffer
alias global bd!  delete-buffer!
alias global rg   grep
def -params 1 setf %{set buffer filetype %arg{1}}

# Math prompt, from alexherbo2
def prompt_math %{
    prompt 'math ' %{ exec a %val{text} <esc> | bc <ret> }
}
map global normal = :prompt_math<ret>

# Auto-mkdir when saving buffer to file, from alexherbo2
hook global -group kakrc BufWritePre .* %{ nop %sh{
  dir=$(dirname $kak_buffile)
  [ -d $dir ] || mkdir --parents $dir
}}

# Remove spaces when saving
hook global -group kakrc BufWritePre .* %{
  try %{ exec -no-hooks -draft '%s\h+$<ret>d' }
}

# Options
set global ui_options ncurses_assistant=none
set global tabstop 4
set global idle_timeout 50

# Insert mode

# silent: stop completion
map global insert <c-s> <c-o>
# complete here
map global insert <c-c> <c-x>
# complete previous
map global insert <c-t> <c-p>
# raw insert, use vim binding
map global insert <c-k> <c-v>
# paste from normal yank register, readline key
map global insert <c-y> '<c-r>"'
# execute one normal kak command
map global insert <c-h> <a-\;>

# Jedi
map global user . :jedi<space>goto<ret>
map global user m :jedi<space>docstring<ret>
map global user u :jedi<space>usages<ret>

# Reload .Xresources upon saving it
rmhooks global reload_xres
hook -group reload_xres global BufWritePost .*Xresources %{
  nop %sh{ xrdb -merge ~/.Xresources }
  echo xrdb -merge %val{bufname}
}

# Window setup
def my-window-setup %{
    try %{ addhl number_lines -hlcursor -separator ' '  }
    try %{ addhl show_matching }
    try %{ addhl dynregex '%opt{curword}' 0:CurWord }

    hook global -group kakrc WinResize .* %{
        echo "%val{window_height}:%val{window_width}"
    }

    rmhl red80
    addhl group red80
    addhl -group red80 regex ^[^\n]{80}([^\n]) 1:default,red

    set window completers filename:word=all

    # auto indent
    hook -group copyindent window InsertChar \n %{ exec -draft -itersel K<a-&> }

    # Auto expand tabs into spaces
    hook -group expandtabs window InsertChar \t %{ exec -draft -itersel h@ }

    try %{ set global grepcmd 'rg -n' }
}

hook global -group kakrc BufCreate .*(bashrc|xinitrc).* %{
    set buffer filetype sh
}

hook global -group kakrc WinCreate .* my-window-setup

hook global -group kakrc WinSetOption filetype=python %{
    try jedi-start
    jedi-enable-autocomplete
}

hook global -group kakrc BufCreate .*kak.* "set -add buffer completion_extra_word_char -"

hook global -group kakrc InsertCompletionShow .* %{
    map window insert <tab> <c-n>
    map window insert <backtab> <c-p>
}
hook global -group kakrc InsertCompletionHide .* %{
    unmap window insert <tab> <c-n>;
    unmap window insert <backtab> <c-p>
}

hook global -group kakrc BufOpenFifo '\*grep\*' %{ map global user n ':grep-next<ret>' }

hook global -group kakrc WinSetOption filetype=(c|cpp) %{
    clang-enable-autocomplete
    clang-enable-diagnostics
    alias window lint clang-parse
    alias window lint-next clang-diagnostics-next
    %sh{
        if [ $PWD = "/home/dan/code/kakoune/src" ]; then
           echo "set buffer clang_options '-std=c++14 -DKAK_DEBUG'"
           # -include-pch precomp-header.h.gch -DKAK_DEBUG'"
        fi
    }
    #ycmd-enable-autocomplete
}

hook global -group kakrc WinSetOption filetype=sh %{
    set buffer lintcmd 'shellcheck -fgcc -eSC2006'
    lint-enable
}

hook global -group kakrc WinSetOption filetype=python %{
    set buffer lintcmd 'flake8 --filename=*'
    lint-enable
}

def ide %{
    rename-client main
    new rename-client docs
    new rename-client tools
    set global docsclient docs
    set global toolsclient tools
    set global jumpclient main
}

%sh{
# Keys looking for a purpose
Unassigned='
    <A-x>
    L
    <a-l>
    <a-L>
    C
    _
    <a-c>
    <a-C>
'
for k in $Unassigned; do
    echo map global normal "$k" "':echo $k unbound<ret>'"
done

Sources='
    autowrap.kak
    fzf.kak
    hl-curword.kak
    marks-submap.kak
    nonempty-lines.kak
    one-char-replace.kak
    overwrite.kak
    reload-kakrc.kak
    same-point-insert.kak
    selections.kak
    z-submap.kak
'
for f in $Sources; do
    echo try %@ source $XDG_CONFIG_HOME/kak/$f @
done
}

colorscheme solarized
