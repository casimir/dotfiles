set global ui_options ncurses_assistant=none

# make Alt-commands available as user commands (unless they are shadowed below)
%sh{
python - <<PY
import string
for i in string.printable[:95]:
  if i != '\\\\':
    lhs = repr(i)
    rhs = repr('<A-'+i+'>') if i != '>' else '<a-lt>'
    print('map global user -- ' + lhs + ' ' + rhs)
PY
}

map global user \; <A-:>
map global user 8 *:add-slash-hl<ret>
map global normal * "lbhe*:add-slash-hl<ret>"

set global idle_timeout 50

def -allow-override -params 1 select-closest %{ %sh{
python - $1 $kak_selection_desc $kak_selections_desc <<PY
import sys
goto, current, all = sys.argv[1:]
all = all.split(':')
def key(t):
    desc = t[1]
    return abs(int(goto) - int(desc.split('.')[0]))
best_index, _ = min(enumerate(all), key=key)
current_index = all.index(current)
rots = best_index - current_index
if rots < 0: rots += len(all)
if rots != 0:
    print("exec {}'".format(rots))
print("print-selection-info")
PY
}}

def -allow-override print-selection-info %{ %sh{
IFS=':' read -ra sels <<< "$kak_selections_desc"
for i in "${!sels[@]}"; do
   if [[ "${sels[$i]}" = "${kak_selection_desc}" ]]; then
       echo "echo selection $((i+1))/${#sels[@]}";
       break;
   fi
done
}}

def -allow-override replace-if-all-single-char %{ %sh{
python - $kak_selections_desc <<PY
import sys
for desc in sys.argv[1].split(':'):
    anchor, cursor = desc.split(',')
    if anchor != cursor:
        print("exec c")
        break
else:
    print("one-char-replace")
PY
}}

def -allow-override one-char-replace %{
  hook window -group one-char-replace InsertChar .* %{
    exec <right><backspace>
    remove-hooks window one-char-replace
  }
  hook window -group one-char-replace InsertEnd .* %{
   remove-hooks window one-char-replace
  }
  exec i
}

# silent: stop completion
map global insert <c-s> <c-o>
# complete here
map global insert <c-c> <c-x>
# complete previous
map global insert <c-t> <c-p>
# raw insert, use vim binding
map global insert <c-k> <c-v>
# paste from normal yank register
map global insert <c-p> '<c-r>"'
# execute one normal kak command
map global insert <c-h> <a-\;>

# execute current selection(s)
map global user x %{:eval -itersel %val{selection}<ret>}

# insert with support for count
def -allow-override -params 1 urk %{
    exec -no-hooks \;i.<esc>hyd %arg{1} P %arg{1} Hs.<ret><a-space>c
}
map global user i %{:urk %val{count}<ret>}

# less intrusive c
map global normal c :replace-if-all-single-char<ret>

map global user d %{ :delete-buffer<ret>:exec ga<ret> }
map global normal '#' :comment-line<ret>

def -allow-override rm-slash-hl %{
  rmhl dynregex_\%reg{<slash>}
}
def -allow-override add-slash-hl %{
  rm-slash-hl
  try %{
    addhl dynregex '%reg{/}' 0:+u 1:CurWord 2:CurWord
  }
}
hook global NormalKey .*[/?NT].* add-slash-hl

map global user u :rm-slash-hl<ret>
map global normal <esc>   <space>:rm-slash-hl<ret>
map global normal <space> '\;'
map global normal \;      ':'
map global normal :       '<A-;>'
map global normal _       'I<esc>'

# american sign language bindings
map global normal <A-s>   <A-l>
map global normal <A-S>   <A-L>

alias global colo colorscheme
alias global wqa write-all-quit
alias global bd  delete-buffer
alias global bd! delete-buffer!

# my ugly ducklings
map global goto p <esc>:bp<ret>
map global goto n <esc>:bn<ret>
map global goto 2 "<esc>:new-client-here<space>F1<ret>"
map global goto 3 "<esc>:new-client-here<space>F2<ret>"

def -allow-override -params 1 new-client-here %{
  %sh{
    echo "new exec :buffer <space> $kak_buffile <ret> $kak_cursor_line g :%sh{ xdotool <space> key <space> alt+$1 }<ret>"
  }
}

map global normal t     j
map global normal n     k
map global normal s     l
map global normal <A-t> J
map global normal <A-n> K
map global normal S     L

map global normal ( :goto-line-start<ret>
map global normal <A-(> :extend-line-first-word<ret>

def -allow-override goto-line-start %{ try %{ exec gh <a-k> \A\s <ret> <a-K> $ <ret> wl } }
def -allow-override extend-line-first-word %{ try %{ exec Gh <a-k> \A\s <ret> WL } }

def -allow-override move-forward-to-line-start %{
    eval -itersel %{
        try %{
            exec '<a-:><a-;>' <a-k>\A^\h*\z<ret> :goto-line-start<ret>
        }
    }
}

# worm-movements: moving both anchors
map global normal <c-h> 'H<a-;>H<a-;>'
map global normal <c-s> 'L<a-;>L<a-;>'
# worm could also go "through text" text:
# Ysdjhj:<space>Pj
# this would be C-t M-t in emacs on speed, especially with <C-WEB> <C-NT>
# this should probably be a mini mode, a worm mode
# which toggles these maps
# even though it makes sense to do them for just one command

map global goto t j
map global goto n k
map global goto s l
map global goto T j
map global goto N k
map global goto S l
map global goto G e

# next match
map global normal N     n:add-slash-hl<ret>
map global normal <A-N> N:print-selection-info<ret>:add-slash-hl<ret>
map global normal T     <A-n>:add-slash-hl<ret>
map global normal <A-T> <A-N>:print-selection-info<ret>:add-slash-hl<ret>

map global normal x     :nop<ret>
map global normal X     :nop<ret>
map global normal <A-x> :nop<ret>

map global normal x     Z
map global normal <a-x> <A-Z>
map global normal j     z
map global normal <a-j> <A-z>

map global normal J     <A-j>
map global normal <A-J> <A-J>

map global normal k     t
map global normal K     <a-t>
map global normal <a-k> T
map global normal <a-K> <a-T>

map global normal f     f
map global normal F     <a-f>
map global normal <a-f> F
map global normal <a-F> <a-F>

map global user k <a-k>
map global user K <a-K>

# split and select
map global user s s
map global user t S
map global normal l <A-s>
map global normal L :nop<ret>
map global normal <a-l> :nop<ret>
map global normal <a-L> :nop<ret>
map global user '/' :select-all-goto-closest<ret>:add-slash-hl<ret>

def -allow-override select-all-goto-closest %{
exec %sh{echo "\\%s<ret>:select-closest<space>$kak_cursor_line<ret>"}
}

# Put view commands on z instead than v
map global view   z v
map global view   s l
map global normal z v
map global normal Z V

def -allow-override select-line-nicely %{
    goto-line-start
    exec 'Gl'
    # should make it so that if it is nicely selected, selects the next
}

# Put line selection commands on v rather than x
map global normal v     :select-line-nicely<ret>
map global normal V     X
map global normal <A-v> <A-x>
map global normal <A-V> <A-X>

def -allow-override -params 1 setf %{
  set buffer filetype %arg{1}
}

# make new selections above and under
map global normal <c-t> C
map global normal <c-n> <a-C>''
map global normal <a-C> <a-C>''
map global normal C     :nop<ret>
# will be used for other purposes later, vc for :select-line-nicely<ret>c
map global normal d     d
                        # :move-forward-to-line-start<ret>
                        # if we remove a big chunk, we can go to line start
                        # but if we only remove single characters we shouldn't
map global normal D     <a-x>d:move-forward-to-line-start<ret>

map global normal -- - '"'

map global normal '"' "<A-'>:print-selection-info<ret>"
map global normal "'" "':print-selection-info<ret>"


def -hidden -allow-override overwrite %{
  try %{
    hook buffer -group overwrite InsertChar .* %{exec <right><backspace>}
    map buffer insert <backspace> <left>
    hook buffer -group overwrite InsertEnd .* %{
      remove-hooks buffer overwrite
      map buffer insert <backspace> <backspace>
    }
  }
}

map global normal r r
# overwrite a'la vim's R
map global normal R :overwrite<ret>i

# paste and replace on <a-r> for now
map global normal <a-r> R

# copy to  xclipboard
map global user y %{<a-|>xsel -i<ret>:echo -color Information %{yanked to X clipboard}<ret>}
map global user p %{<a-!>xsel<ret>:echo -color Information %{pasted from X clipboard}<ret>}
map global user P %{!xsel<ret>:echo -color Information %{pasted from X clipboard}<ret>}
map global user R %{:reg w "%sh{xsel}"<ret>"wR:echo -color Information %{replaced from X clipboard }<ret>}

# auto-copy on y to x clipboard
hook global NormalKey y %{ nop %sh{
  printf '%s' "${kak_reg_dquote}" | xsel --input
}}


# WIP: this doesn't respect the newlines in the clipboard
def -allow-override set-xclip-clipboard %{ %sh{
  print "set-register c '%s"' "$(xclip -o)"
}}

# hook global NormalIdle .* test


map global user w :w<ret>

# reload kakrc and .kak when saving
rmhooks global reload_kak
hook -group reload_kak global BufWritePost (.*kakrc|.*\.kak) %{
  source %val{buffile}
  echo Reloaded %val{bufname}
}

rmhooks global reload_xres
hook -group reload_xres global BufWritePost .*Xresources %{
  nop %sh{ xrdb -merge ~/.Xresources }
  echo xrdb -merge %val{bufname}
}

set global tabstop 4

decl -hidden regex curword
face CurWord +b
# default,rgb:4a4a4a

def -allow-override remove_spaces %{ try %{ exec -draft '%s\h+$<ret>d' } }

hook global BufWritePre .* remove_spaces

colorscheme solarized

def -allow-override my-window-setup %{
    try %{ addhl number_lines -hlcursor -separator ' '  }
    try %{ addhl show_matching }
    try %{ addhl dynregex '%opt{curword}' 0:CurWord }

    hook global WinResize .* %{
        echo "%val{window_height}:%val{window_width}"
    }

    rmhl red80
    addhl group red80
    addhl -group red80 regex ^[^\n]{80}([^\n]) 1:default,red

    set window completers filename:word=all

    # auto indent
    hook window InsertChar \n %{ exec -draft -itersel K<a-&> }

    # Auto expand tabs into spaces
    hook window InsertChar \t %{ exec -draft -itersel h@ }

    try %{ set global grepcmd 'rg -n' }
}

alias global rg grep

def -hidden -allow-override _update_curword %{
    eval -no-hooks -draft %{ try %{
        exec <space><a-i>w <a-k>\`\w+\'<ret>
        set buffer curword "\b\Q%val{selection}\E\b"
    } catch %{
        set buffer curword ''
    } }
}

hook global NormalIdle .* _update_curword
hook global NormalKey .* _update_curword

hook global BufCreate .*(bashrc|xinitrc).* %{
    set buffer filetype sh
}

hook global WinCreate .* my-window-setup

hook global WinSetOption filetype=python %{
    jedi-enable-autocomplete
}

hook global BufCreate .*kak.* "set -add buffer completion_extra_word_char -"

hook global InsertCompletionShow .* %{
    map window insert <tab> <c-n>
    map window insert <backtab> <c-p>
}
hook global InsertCompletionHide .* %{
    unmap window insert <tab> <c-n>;
    unmap window insert <backtab> <c-p>
}

def fzf -params 0..1 -allow-override %{ %sh{
    tmp=$(mktemp /tmp/kak-fzf.XXXXXX)
    edit=$(mktemp /tmp/kak-edit.XXXXXX)
    echo 'echo eval -client $kak_client "edit $1" | kak -p $kak_session' > $edit
    chmod 755 $edit
    (
        urxvt -e sh -c "rg --ignore-file ~/.binignore -L --hidden --files $1 | fzf -e -m --preview=\"head -n 8 {}\" --preview-window=up:8 --bind 'ctrl-c:execute($edit \"{}\")' > $tmp"
        (while read file; do
            $edit $file
        done) < $tmp
        rm $tmp
    ) > /dev/null 2>&1 < /dev/null &
} }

def bufzf -allow-override %{ %sh{
    tmp=$(mktemp /tmp/kak-fzf.XXXXXX)
    setbuf=$(mktemp /tmp/kak-setbuf.XXXXXX)
    delbuf=$(mktemp /tmp/kak-delbuf.XXXXXX)
    echo 'echo eval -client $kak_client "buffer        $1" | kak -p $kak_session' > $setbuf
    echo 'echo eval -client $kak_client "delete-buffer $1" | kak -p $kak_session' > $delbuf
    echo 'echo eval -client $kak_client bufzf              | kak -p $kak_session' >> $delbuf
    chmod 755 $setbuf
    chmod 755 $delbuf
    (
        urxvt -e sh -c "echo $kak_buflist | tr ':' '\n' | grep -v \"$kak_bufname\" | grep -v \"$kak_buffile\" |
            fzf -0 -1 -e '--preview=$setbuf {}' --preview-window=right:0 --expect ctrl-d > $tmp"
        if [ -s $tmp ]; then
            ( read action
              read buf
              if [ "$action" == "ctrl-d" ]; then
                  $delbuf $buf
              else
                  $setbuf $buf
              fi) < $tmp
        else
            $setbuf $kak_bufname
        fi
        rm $tmp
    ) > /dev/null 2>&1 < /dev/null &
} }

# fzf-line:
# rg \$ -n | fzf '-d:' --with-nth=3.. --preview 'echo {1}:{2}; tail -n +{2} {1}' --no-sort

map global user b ":bufzf<ret>"
map global user h "<esc>:fzf ~<ret>"
map global user f "<esc>:fzf<ret>"
map global goto o "<esc>:info ,f<ret>"
map global goto / "<esc>:grep "

hook global BufOpenFifo '\*grep\*' %{ map global user g ':grep-next<ret>' }

hook global WinSetOption filetype=(c|cpp) %{
    clang-enable-autocomplete
    clang-enable-diagnostics
    alias window lint clang-parse
    alias window lint-next clang-diagnostics-next
    %sh{
        if [ $PWD = "/home/dan/code/kakoune/src" ]; then
           echo "set buffer clang_options '-std=c++14 -include-pch precomp-header.h.gch -DKAK_DEBUG'"
        fi
    }
    #ycmd-enable-autocomplete
}

hook global WinSetOption filetype=sh %{
    set buffer lintcmd 'shellcheck -fgcc -eSC2006'
    lint-enable
}

hook global WinSetOption filetype=python %{
    set buffer lintcmd 'flake8 --filename=*'
    lint-enable
}

map global user q '|fmt -w 80<ret>:echo -color green [sel] | fmt -w 80<ret>'
map global goto q <esc><a-i>p,q
# ^ similar to gqq in vim

def -allow-override ide %{
    rename-client main
    new rename-client docs
    new rename-client tools
    set global docsclient docs
    set global toolsclient tools
    set global jumpclient main
}

